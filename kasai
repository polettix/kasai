#!/usr/bin/env perl
use 5.024001;
use warnings;
use experimental qw< postderef signatures >;
no warnings qw< experimental::postderef experimental::signatures >;

BEGIN {
   if (!eval { require Curses }) {
      require FindBin;
      eval "use lib '$FindBin::Bin/local/lib/perl5'";
   }
}

use Curses;

use constant WIDTH  => 80;
use constant HEIGHT => 24;

my $log = sub { say {*STDERR} "@_" };

package GnW::Position {
   use Moo;
   use warnings;
   use experimental qw< postderef signatures >;
   no warnings qw< experimental::postderef experimental::signatures >;
   use Ouch ':trytiny_var';
   use Scalar::Util qw< blessed refaddr >;

   has id        => (is => 'rw', default => sub ($s) { refaddr($s) });
   has current   => (is => 'rw', weak_ref => 1, default => undef);
   has succ_for  => (is => 'rw', default => sub { return {} });
   has ui_data   => (is => 'rw');

   sub remove_if_current ($self, $item) {
      return unless defined $item;
      my $current = $self->current // return;
      return unless ref($current) eq ref($item); # not same "type"
      if (ref($current)) { # references, check for identity
         return if refaddr($current) != refaddr($item);
      }
      else { # plain scalars, equality will do
         return if $current ne $item;
      }
      $self->current(undef); # definitely get rid of it
      return;
   }

   sub successor_for ($self, $direction) {
      return $self->succ_for->{$direction} // undef;
   }

   sub set_ui_data_recurse ($self, $href) {
      return if $self->ui_data;
      $self->ui_data($href->{$self->id});
      $_->set_ui_data_recurse($href) for values $self->succ_for->%*;
      return $self;
   }

   sub _recursive_traverse_positions ($self, $callback_for, $done) {
      my ($ppos, $pre, $post) = $callback_for->@{qw< pre_pos pre post >};
      return if $done->{$self->id}++;
      $pre->($self) if $pre;
      for my $p (values $self->succ_for->%*) {
         $log->("@{[$p]}");
         $ppos->($p) if $ppos;
         $p->_recursive_traverse_positions($callback_for, $done);
      }
      $post->($self) if $post;
      return;
   }

   sub traverse_positions ($self, %callback_for) {
      $self->_recursive_traverse_positions(\%callback_for, {});
      return $self;
   }
}

package GnW::Interaction {
   use Moo;
   use warnings;
   use experimental qw< postderef signatures >;
   no warnings qw< experimental::postderef experimental::signatures >;
   use Ouch ':trytiny_var';

   has name => (is => 'rw', default => 'bump');
   has position_for => (is => 'rw');
   has action => (is => 'rw');

   sub update ($self, $event, $game) {
      my $action = $self->action or return $self->_default($event, $game);
      $action->($self, $event, $game);
      return $self;
   }

   sub _default ($self, $event, $game) { # this is a default implementation
      my ($cpos, $tpos) = $self->position_for->@{qw< catcher target >};
      my $target = $tpos->current or return;
      my $catcher = $cpos->current or return;
      $_->record_interaction($self->name) for ($target, $catcher);
      $game->increase;
      return;
   }

   sub set_ui_data ($self, $href) {
      $_->set_ui_data_recurse($href) for values $self->position_for->%*;
      return $self;
   }

   sub traverse_positions ($self, %callback_for) {
      my ($pre, $post, $pos) = @callback_for{qw< pre post pos >};
      for my $p (values $self->position_for->%*) {
         $pre->($p) if $pre;
         $p->traverse_positions($pos->%*) if scalar keys $pos->%*;
         $post->($p) if $post;
      }
      return $self;
   }
}

package GnW::Item {
   use Moo;
   use warnings;
   use experimental qw< postderef signatures >;
   no warnings qw< experimental::postderef experimental::signatures >;
   use Ouch ':trytiny_var';
   use Scalar::Util 'refaddr';

   has id            => (is => 'rw', default => sub ($s) { refaddr($s) });
   has position      => (is => 'rw');
   has locked        => (is => 'rw', default => 0);
   has direction_for => (is => 'rw', default => sub { return {} });
   has _interaction  => (is => 'rw', default => undef);

   sub update ($self, $event) {
      $log->('item:', $self->id);

      # skip if it's not an event this object would normally react to
      my $df = $self->direction_for->{$event} or return $self;

      my $position = $self->position;
      if ($position && ! $self->locked) {
         $position->remove_if_current($self);
         my $interaction = $self->_interaction // 'default';
         my ($x, $y) = $position->ui_data->@{qw< x y >};
         $log->("event<$event> interaction<$interaction> position($x, $y)");
         my $direction = $df->{$interaction};
         $self->move_to($position->successor_for($direction));
      }

      # whatever happened, any interaction is cleared for next round
      $self->_interaction(undef);
      return $self;
   }

   sub move_to ($self, $position) {
      $self->position($position);
      $position->current($self);
      return $self;
   }

   sub record_interaction($self, $interaction) {
      $self->_interaction($interaction);
      return $self;
   }

   sub traverse_positions ($self, %callback_for) {
      my ($pre, $post, $pos) = @callback_for{qw< pre post pos >};
      my $p = $self->position;
      $pre->($p) if $pre;
      $p->traverse_positions($pos->%*) if scalar keys $pos->%*;
      $post->($p) if $post;
      $self->position($p); # nothing done really in case...
      return $self;
   }
}

package GnW::Source {
   use Moo;
   use warnings;
   use experimental qw< postderef signatures >;
   no warnings qw< experimental::postderef experimental::signatures >;
   use Ouch ':trytiny_var';

   extends 'GnW::Interaction';

   sub _default ($self, $event, $game) { # this is a default implementation
      return unless $event eq 'generate';
      my $pf = $self->position_for;
      my ($position) = exists $pf->{default} ? $pf->{default}
         : map {$pf->{$_}} sort {$a cmp $b} keys $pf->%*;
      $game->add_item(
         GnW::Item->new(
            position => $position,
            locked   => 0,
            direction_for => {
               advance => {
                  default => 'default',
                  bump    => 'alternative',
               },
            },
         )
      );
      return;
   }
}

package GnW::Sink {
   use Moo;
   use warnings;
   use experimental qw< postderef signatures >;
   no warnings qw< experimental::postderef experimental::signatures >;
   use Ouch ':trytiny_var';

   extends 'GnW::Interaction';

   sub _default ($self, $event, $game) {
      while (my ($counter, $position) = each $self->position_for->%*) {
         my $item = $position->current or next;
         $log->("   have current $item -> $counter");
         $game->increase($counter);
         $game->remove_item($item);
      }
      return;
   }
}

package GnW::Counter {
   use Moo;
   use warnings;
   use experimental qw< postderef signatures >;
   no warnings qw< experimental::postderef experimental::signatures >;
   use Ouch ':trytiny_var';
   use Scalar::Util qw< blessed refaddr >;

   has name  => (is => 'rw', default => 'foo');
   has value => (is => 'rw', default => 0);
   has max   => (is => 'rw', default => undef);
   has min   => (is => 'rw', default => undef);
   has upper_threshold => (is => 'rw', default => undef);
   has lower_threshold => (is => 'rw', default => undef);

   sub is_outside ($self) {
      my $value = $self->value;
      my $upper = $self->upper_threshold // $value;
      my $lower = $self->lower_threshold // $value;
      return ($value < $lower) || ($value > $upper);
   }

   sub increase ($self) {
      die "counter @{[$self->name]} is outside thresholds\n"
        if $self->is_outside;
      my $value = $self->value;
      my $max   = $self->max // ($value + 1);
      $self->value($value + 1) if $value < $max;
      return $self;
   }

   sub decrease ($self) {
      die "counter @{[$self->name]} is outside thresholds\n"
        if $self->is_outside;
      my $value = $self->value;
      my $min   = $self->min // ($value - 1);
      $self->value($value - 1) if $value > $min;
      return $self;
   }
}

package GnW::SyncEvent {
   use Moo;
   use warnings;
   use experimental qw< postderef signatures >;
   no warnings qw< experimental::postderef experimental::signatures >;

   use constant DEFAULT_PERIOD => 25;

   has min_tick => (is => 'rw', default => 0);
   has max_tick => (is => 'rw', default => -1);
   has offset   => (is => 'rw', default => 0);
   has period   => (is => 'rw', default => DEFAULT_PERIOD);
   has name     => (is => 'rw', default => 'tock');

   sub tick ($self, $n) {
      my ($min_tick, $max_tick) = ($self->min_tick, $self->max_tick);
      return if $n < $min_tick;
      return if ($max_tick >= 0) && ($n > $max_tick);
      $n = ($n - $min_tick) % $self->period;
      return unless $n == $self->offset;
      return $self->name;
   }
}

package GnW::Game {
   use Moo;
   use warnings;
   use experimental qw< postderef signatures >;
   no warnings qw< experimental::postderef experimental::signatures >;
   use Ouch ':trytiny_var';
   use Scalar::Util qw< blessed refaddr >;
   use GnW::Counter;

   use constant GO_MISSES => 3;

   has counter_for => (
      is => 'rw',
      default => sub {
         return {
            score => GnW::Counter->new(name => 'score'),
            safe  => GnW::Counter->new(name => 'safe'),
            miss  => GnW::Counter->new(
               name => 'miss',
               upper_threshold => (GO_MISSES - 1),
            ),
         };
      },
   );
   has interactions => (is => 'rw', default => sub { return [] });
   has sync_events => (is => 'rw', default => sub { return [] });
   has _ticks => (is => 'rw', clearer => 1, default => 0);
   has _items => (is => 'rw', default => sub { return {} });
   has _changes => (is => 'rw', default => sub { return {} });
   has positions => (is => 'lazy', init_arg => undef);
   has is_game_over => (is => 'rw', default => sub {\&_is_over});

   around BUILDARGS => sub ($orig, $class, @args) {
      my %args = @args && ref($args[0]) ? $args[0]->%* : @args;
      if (my $definition = delete $args{definition}) {
         %args = (%args, $class->_revive($definition));
      }
      if (my $items = delete $args{items}) {
         $args{_items} = { map {refaddr($_) => $_} $items->@* };
      }
      return $class->$orig(\%args);
   };

   sub tick ($self, @async_events) {
      my $ticks = ($self->_ticks // 0) + 1;
      $self->_ticks($ticks);
      my @sync_events = map { $_->tick($ticks) } $self->sync_events->@*;
      $self->update($_) for (@async_events, @sync_events);
      return $self;
   }

   # items facility
   sub add_item ($self, $item) {
      $self->_items->{refaddr($item)} = $item;
      $log->('add item in position ' . $item->position->id);
      $item->move_to($item->position);
      return $self;
   }
   sub remove_item ($self, $item) {
      delete $self->_items->{refaddr($item)};
      return $self;
   }
   sub items ($self) { return values $self->_items->%* }

   # counters facility, default counter is 'score'
   sub increase ($self, $name = 'score') {
      $self->counter_for->{$name}->increase;
      $self->_changes->{$name}++;
      return $self;
   }
   sub decrease ($self, $name = 'score') {
      $self->counter_for->{$name}->decrease;
      $self->_changes->{$name}++;
      return $self;
   }
   sub total ($s, $n = 'score') { return $s->counter_for->{$n}->value }
   sub last_update_changes ($self) { return $self->_changes->%* }

   # positions facility, actually builds the cache of positions
   sub _build_positions ($self) {
      my %position_for;
      my $collector = sub ($p) { $position_for{$p->id} //= $p };
      $_->traverse_positions(pos => { pre => $collector })
         for ($self->interactions->@*, values $self->_items->%*);
      return [values %position_for];
   }

   sub update ($self, $event) { # e.g. advance, move, ...
      $self->_changes({}); # reset
      $_->update($event) for values $self->_items->%*;
      $_->update($event, $self)  for $self->interactions->@*;
      return $self;
   }

   sub is_over ($self) { $self->counter_for->{'miss'}->is_outside }

   sub set_ui_data ($self, $href) {
      $_->set_ui_data($href) for $self->interactions->@*;
      return $self;
   }

   sub __instance($default_class, $candidate) {
      return $candidate if blessed($candidate);
      my %args = $candidate->%*;
      my $class = delete($args{_class}) // $default_class;
      return $class->new(%args);
   }

   sub _revive ($class, $href) {
      my ($positions, $interactions, $items, $syevents) = map { $_ // [] }
         $href->@{qw< positions interactions items sync_events >};

      my @sync_events = map { GnW::SyncEvent->new($_) } $syevents->@*;

      # handle positions. First create them all, then link them based
      # on a translation from their identifier to their reference
      my %position_for;
      for my $i ($positions->@*) {
         my $p = __instance('GnW::Position', $i);
         my $id = $p->id;
         die "duplicate position id $id\n" if exists $position_for{$id};
         $position_for{$id} = $p;
      }
      my $res = sub { $_[0] = $position_for{$_[0]} unless ref $_[0] };
      $_->traverse_positions(pre_pos => $res) for values %position_for;

      # now handle interactions. Positions are all ok by now
      my @interactions = map {
         my $i = __instance('GnW::Interaction', $_);
         $i->traverse_positions(pre => $res);
         $i;
      } $interactions->@*;

      # now place any initial item
      my @items = map {
         my $i = __instance('GnW::Item', $_);
         $i->traverse_positions(pre => $res);
         $i->move_to($i->position); # ensure position is aware too
         $i;
      } $items->@*;

      return (
         interactions => \@interactions,
         items        => \@items,
         sync_events  => \@sync_events,
      );
   }
}

my $demo = {
   positions => [
      { id => 'traj-11',  succ_for => { default => 'traj-12' } },
      { id => 'traj-11b', succ_for => { default => 'traj-14' } },
      { id => 'traj-12',  succ_for => { default => 'traj-13' } },
      { id => 'traj-13',  succ_for => { default => 'traj-14' } },
      { id => 'traj-14',  succ_for => { default => 'bumped-1' } },
      {
         id => 'bumped-1',
         succ_for => {
            default     => 'pre-miss-1',
            alternative => 'traj-21',
         },
      },
      { id => 'pre-miss-1', succ_for => { default => 'miss' } },

      { id => 'traj-21',  succ_for => { default => 'traj-22' } },
      { id => 'traj-22',  succ_for => { default => 'traj-23' } },
      { id => 'traj-23',  succ_for => { default => 'traj-24' } },
      { id => 'traj-24',  succ_for => { default => 'traj-25' } },
      { id => 'traj-25',  succ_for => { default => 'traj-26' } },
      { id => 'traj-26',  succ_for => { default => 'traj-27' } },
      { id => 'traj-27',  succ_for => { default => 'bumped-2' } },
      {
         id => 'bumped-2',
         succ_for => {
            default     => 'pre-miss-2',
            alternative => 'traj-31',
         },
      },
      { id => 'pre-miss-2', succ_for => { default => 'miss' } },

      { id => 'traj-31',  succ_for => { default => 'traj-32' } },
      { id => 'traj-32',  succ_for => { default => 'traj-33' } },
      { id => 'traj-33',  succ_for => { default => 'traj-34' } },
      { id => 'traj-34',  succ_for => { default => 'traj-35' } },
      { id => 'traj-35',  succ_for => { default => 'bumped-3' } },
      {
         id => 'bumped-3',
         succ_for => {
            default     => 'pre-miss-3',
            alternative => 'traj-41',
         },
      },
      { id => 'pre-miss-3', succ_for => { default => 'miss' } },

      { id => 'traj-41',  succ_for => { default => 'traj-42' } },
      { id => 'traj-42',  succ_for => { default => 'traj-43' } },
      { id => 'traj-43',  succ_for => { default => 'safe' } },

      { id => 'miss' },
      { id => 'safe' },

      { id => 'left', succ_for => { left => 'left', right => 'center' } },
      { id => 'center', succ_for => { left => 'left', right => 'right' } },
      { id => 'right', succ_for => { left => 'center', right => 'right' } },
   ],
   interactions => [
      {
         name => 'source',
         _class => 'GnW::Source',
         position_for => { default => 'traj-11' },
      },
      {
         name => 'sink',
         _class => 'GnW::Sink',
         position_for => { miss => 'miss', safe => 'safe' },
      },
      {
         name => 'bump',
         position_for => {
            catcher => 'left',
            target  => 'bumped-1',
         },
      },
      {
         name => 'bump',
         position_for => {
            catcher => 'center',
            target  => 'bumped-2',
         },
      },
      {
         name => 'bump',
         position_for => {
            catcher => 'right',
            target  => 'bumped-3',
         },
      },
   ],
   items => [
      {
         locked => 0,
         position => 'left',
         direction_for => {
            left   => {default => 'left',   bump => 'left'},
            center => {default => 'center', bump => 'center'},
            right  => {default => 'right',  bump => 'right'},
         },
      }
   ],
   sync_events => [
      {
         min_tick => 0,
         max_tick => -1,
         offset   => 0,
         period   => 25,
         name     => 'advance',
      },
      {
         min_tick => 0,
         max_tick => -1,
         offset   => 0,
         period   => 5 * 25,
         name     => 'generate',
      },
   ],
};

my $demo_curses = {
   position_for => {
      'traj-11'    => { x =>  1, y =>  3, draw => '*', erase => ' '},
      'traj-11b'   => { x =>  1, y =>  6, draw => '*', erase => ' '},
      'traj-12'    => { x =>  2, y =>  4, draw => '*', erase => ' '},
      'traj-13'    => { x =>  3, y =>  6, draw => '*', erase => ' '},
      'traj-14'    => { x =>  4, y =>  8, draw => '*', erase => ' '},
      'bumped-1'   => { x =>  5, y => 11, draw => '*', erase => ' '},
      'pre-miss-1' => { x =>  5, y => 13, draw => 'XXX', erase => '---'},
      'traj-21'    => { x =>  7, y =>  8, draw => '*', erase => ' '},
      'traj-22'    => { x =>  9, y =>  6, draw => '*', erase => ' '},
      'traj-23'    => { x => 12, y =>  4, draw => '*', erase => ' '},
      'traj-24'    => { x => 16, y =>  3, draw => '*', erase => ' '},
      'traj-25'    => { x => 20, y =>  4, draw => '*', erase => ' '},
      'traj-26'    => { x => 23, y =>  6, draw => '*', erase => ' '},
      'traj-27'    => { x => 25, y =>  8, draw => '*', erase => ' '},
      'bumped-2'   => { x => 27, y => 11, draw => '*', erase => ' '},
      'pre-miss-2' => { x => 27, y => 13, draw => 'XXX', erase => '---'},
      'traj-31'    => { x => 29, y =>  8, draw => '*', erase => ' '},
      'traj-32'    => { x => 32, y =>  6, draw => '*', erase => ' '},
      'traj-33'    => { x => 36, y =>  5, draw => '*', erase => ' '},
      'traj-34'    => { x => 40, y =>  6, draw => '*', erase => ' '},
      'traj-35'    => { x => 43, y =>  8, draw => '*', erase => ' '},
      'bumped-3'   => { x => 45, y => 11, draw => '*', erase => ' '},
      'pre-miss-3' => { x => 45, y => 13, draw => 'XXX', erase => '---'},
      'traj-41'    => { x => 47, y =>  9, draw => '*', erase => ' '},
      'traj-42'    => { x => 50, y =>  8, draw => '*', erase => ' '},
      'traj-43'    => { x => 53, y =>  9, draw => '*', erase => ' '},

      'left'     => { x =>  3, y => 12, draw => '@---@', erase => '     '},
      'center'   => { x => 25, y => 12, draw => '@---@', erase => '     '},
      'right'    => { x => 43, y => 12, draw => '@---@', erase => '     '},
   },
   background => <<'END',
[  ~~~~~ ~~~~                                      MISS
|=~~~~ ~~~                                              
|~~~
[                
|=                   
|                                    
[                                        
|=
|                                                  
[                                                     
|=                                                     __n_
|                                                     [ +  \
[                                                     "o--o"
------------------------------------------------------------
END
   misses => [
      { x => 51, y => 1, draw => '0', erase => ' ' },
      { x => 53, y => 1, draw => '0', erase => ' ' },
      { x => 55, y => 1, draw => '0', erase => ' ' },
   ],
};

package Demo::Game::Curses {
   use Moo;
   use 5.024001;
   use warnings;
   use experimental qw< postderef signatures >;
   no warnings qw< experimental::postderef experimental::signatures >;
   use Curses;
   use Time::HiRes qw< clock_gettime CLOCK_MONOTONIC >;
   use constant FRAMES_PER_SECOND => 25;
   use constant FRAME_DURATION    => (1.0 / FRAMES_PER_SECOND);

   use GnW::Game;

   sub _update ($self, $game, $event, $win) {
      my @positions = $game->positions->@*;
      if ($event eq 'tick') { $game->tick }
      else                  { $game->update($event) }
      for my $position (@positions) {
         my $ud = $position->ui_data;
         my $current = $position->current ? 'draw' : 'erase';
         next if $current eq ($ud->{previous} //= 'erase');
         $ud->{previous} = $current;
         $win->addstr($ud->@{'y', 'x', $current});
      }

      $win->addstr( 0, 26, ($game->total('score') // 0));

      my $misses = $game->total('miss') // 0;
      $win->addstr($demo_curses->{misses}[$_]->@{qw< y x draw >})
         for 0 .. $misses - 1;
      $win->refresh;
   }

   sub init_win ($self) {
      my $win = Curses->new;
      curs_set(0);
      noecho();
      $win->keypad(1);
      my @background = split m{\n}mxs, $demo_curses->{background};
      $win->addstr($_, 0, $background[$_]) for 0 .. $#background;
      $win->refresh;
      return $win;
   }

   sub run ($self) {
      my $game = GnW::Game->new(definition => $demo);
      $game->set_ui_data($demo_curses->{position_for});
      my $win = $self->init_win;
      my $alarm = clock_gettime(CLOCK_MONOTONIC);
      DONE:
      while (! $game->is_over) {
         INPUT:
         while ((my $clk = clock_gettime(CLOCK_MONOTONIC)) < $alarm) {
            #if (my @ready = $selector->can_read($alarm - $clk)) {
            #   my $key = $win->getch;
            $win->timeout(int(1000 * ($alarm - $clk)));
            my ($ch, $key) = $win->getch;
            if (defined ($key //= $ch)) {
               next INPUT if $key eq ERR;
               last DONE if $key eq 'q' || $key eq "\x{1b}";
               $self->_update($game, 'left', $win)
                  if $key eq 'a' || $key eq '260';
               $self->_update($game, 'right', $win)
                  if $key eq 'l' || $key eq '261';
            }
            else {
               last DONE;
            }
         }
         $self->_update($game, 'tick', $win);
         $alarm += FRAME_DURATION;
      }
      $win->addstr(3, 20, 'GAME OVER');
      $win->refresh;
      $win->timeout(-1);
      $win->getch;
      endwin();
   }
}

package Kasai::Curses {
   use Moo;
   use 5.024001;
   use warnings;
   use experimental qw< postderef signatures >;
   no warnings qw< experimental::postderef experimental::signatures >;
   use Curses;
   use Time::HiRes qw< sleep >;

   has trajectories => (is => 'rw');
   has field        => (is => 'rw');

   sub _read_field ($self, $field) {
      open my $fh, '<', \$field or die "open(): $!\n";

      my @field;
      my %pos_for;
      my $y = 0;
      $pos_for{path} = \my @path;
      $pos_for{savers} = \my @savers;

      my @paths;
      while (<$fh>) {
         my ($type, @line) = split m{}mxs;
         if ($type eq '$') { # where the score will be
            for my $x (0 .. $#line) {
               if ($line[$x] eq '$') {
                  $pos_for{score} = [$y, $x];
                  $line[$x] = ' ';
               }
            }
         }
         elsif ($type eq '0') {
            $pos_for{miss} = \my @misses;
            for my $x (0 .. $#line) {
               if ($line[$x] eq '0') {
                  push @misses, [$y, $x];
                  $line[$x] = ' ';
               }
            }
         }
         elsif (($type eq '@') || ($type eq '?')) {
            for my $x (0 .. $#line) {
               (my $v = $line[$x]) =~ m{\d}mxs or next;
               my $tp = Kasai::TrajectoryPosition->new(
                  position => {x => $x, y => $y},
                  can_fail => ($type eq '?'),
               );
               push @{$paths[$v]}, $tp;
               $line[$x] = ' ';
            }
         }
         elsif ($type eq '!') {
            $_ = '-' for @line;
         }
         elsif ($type eq '&') {
            for (my $x = 0; $x < @line; ) {
               if ($line[$x] eq '@') {
                  push @savers, [$y, $x];
                  while ($line[$x] ne ' ') {
                     $line[$x++] = ' ';
                  }
               }
               else {
                  $x++;
               }
            }
         }
         push @field, \@line;
         ++$y;
      }

      use Data::Dumper; $Data::Dumper::Indent = 1;

      my @starts;
      for my $p (@paths) {
         my ($s, @p) = sort {($a->{x} <=> $b->{x}) || ($a->{y} <=> $b->{y})} @$p;
         push @starts, $s;
         ($s->{next}, $s) = ($_, $_) for @p;
         $s->{next} = $starts[0] if @starts > 1;
      }
      shift @starts;

      print Dumper \@starts; exit 0;

      return {
         field => \@field,
         pos_for => \%pos_for,
         paths => \@starts,
      };
   }
}

use Demo::Game::Curses;
my $dc = Demo::Game::Curses->new;
$dc->run;
exit 0;

__DATA__
$[  ~~~~~ ~~~~            $                         MISS
0|=~~~~ ~~~                                         0 0 0
 |~~~
@[1              0
@|=1         0       0
@|                                   0
@[2 1     0             0        0       0
@|=
@|   0  0                 0   0             0      0
@[                                              0     0
@|=                                                     __n_
?|    0                     0                 0        [ +  \
&[  @---@                 @---@             @---@      "o--o"
-------------------------------------------------------------
